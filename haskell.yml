-
  nam: p6
  src: |
        1 == 1
  exp: |
        Prelude> True
-
  nam: p6
  src: |
        2 /= 3
  exp: |
        Prelude> True

-
  nam: wojte
  src: |
    hello "w"
  exp: |
    Prelude> 
    <interactive>:2:1: Not in scope: ‘hello’
-
  nam: checking_type_of_a
  src: |
    :type 'a'
  exp: |
    Prelude> 'a' :: Char
-
  nam: glueing_lists
  src: |
    [1,2] ++ [3,4]
  exp: |
    Prelude> [1,2,3,4]
-
  nam: operator_plus_presence
  src: |
    :info (+)
  exp: |
    Prelude> class Num a where
      (+) :: a -> a -> a
      ...
      	-- Defined in ‘GHC.Num’
    infixl 6 +
-
  nam: type_of_list
  src: |
    :type (1, 2)
  exp: |
    Prelude> (1, 2) :: (Num t1, Num t) => (t, t1)
-
  nam: testing_type_numbers
  src: |
    odd 3
    odd 6
    odd 1.12
  exp: |
    Prelude> True
    Prelude> False
    Prelude> 
    <interactive>:4:1:
        No instance for (Integral a0) arising from a use of ‘odd’
        The type variable ‘a0’ is ambiguous
        Note: there are several potential instances:
          instance Integral Int -- Defined in ‘GHC.Real’
          instance Integral Integer -- Defined in ‘GHC.Real’
          instance Integral GHC.Types.Word -- Defined in ‘GHC.Real’
        In the expression: odd 1.12
        In an equation for ‘it’: it = odd 1.12
    
    <interactive>:4:5:
        No instance for (Fractional a0) arising from the literal ‘1.12’
        The type variable ‘a0’ is ambiguous
        Note: there are several potential instances:
          instance Fractional Double -- Defined in ‘GHC.Float’
          instance Fractional Float -- Defined in ‘GHC.Float’
          instance Integral a => Fractional (GHC.Real.Ratio a)
            -- Defined in ‘GHC.Real’
        In the first argument of ‘odd’, namely ‘1.12’
        In the expression: odd 1.12
        In an equation for ‘it’: it = odd 1.12
-
  nam: testing_integers_and_floats
  src: |
    compare 2 1
    compare 3 4.12
  exp: |
    Prelude> GT
    Prelude> LT
-
  nam: test_type_of_LT
  src: |
    :type LT
  exp: |
    Prelude> LT :: Ordering
-
  nam: tail_and_head
  src: |
    head [ 1, 2, 3, 4 ]
    tail [ 'w', 'o', 'j' ]
  exp: |
    Prelude> 1
    Prelude> "oj"
